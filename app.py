import streamlit as st
import google.generativeai as genai
import pandas as pd
import json
import datetime
from typing import Dict, List, Any
import re
import hashlib
import html
import difflib

# „Éö„Éº„Ç∏Ë®≠ÂÆö
st.set_page_config(
    page_title="LLM„Éó„É≠„É≥„Éó„ÉàËá™ÂãïË©ï‰æ°„Ç∑„Çπ„ÉÜ„É†",
    page_icon="üöÄ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# „Ç´„Çπ„Çø„É†CSS
st.markdown("""
<style>
    .stButton > button {
        width: 100%;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 0.75rem;
        border-radius: 8px;
        font-weight: bold;
        font-size: 1.1rem;
    }
    .metric-card {
        background: white;
        padding: 1rem;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        text-align: center;
        border: 1px solid #e0e0e0;
    }
    .response-box {
        background: #ffffff;
        color: #2c3e50;
        padding: 2rem;
        border-radius: 10px;
        border-left: 4px solid #667eea;
        margin: 1rem 0;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .evaluation-box {
        background: #ffffff;
        color: #2c3e50;
        padding: 2rem;
        border-radius: 10px;
        border-left: 4px solid #f5576c;
        margin: 1rem 0;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .commit-card {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 1rem;
        margin: 0.5rem 0;
    }
    .commit-hash {
        font-family: monospace;
        color: #6c757d;
        font-size: 0.9rem;
    }
    .branch-tag {
        display: inline-block;
        background: #28a745;
        color: white;
        padding: 0.2rem 0.5rem;
        border-radius: 12px;
        font-size: 0.8rem;
        margin-right: 0.5rem;
    }
    .tag-label {
        display: inline-block;
        background: #ffc107;
        color: #212529;
        padding: 0.2rem 0.5rem;
        border-radius: 12px;
        font-size: 0.8rem;
        margin-right: 0.5rem;
    }
    .diff-added {
        background: #d4edda;
        color: #155724;
        padding: 0.2rem;
    }
    .diff-removed {
        background: #f8d7da;
        color: #721c24;
        padding: 0.2rem;
    }
</style>
""", unsafe_allow_html=True)

# „Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖã„ÅÆÂàùÊúüÂåñ
if 'evaluation_history' not in st.session_state:
    st.session_state.evaluation_history = []
if 'api_key' not in st.session_state:
    st.session_state.api_key = ""
if 'current_branch' not in st.session_state:
    st.session_state.current_branch = "main"
if 'branches' not in st.session_state:
    st.session_state.branches = {"main": []}
if 'tags' not in st.session_state:
    st.session_state.tags = {}
if 'selected_model' not in st.session_state:
    st.session_state.selected_model = "gemini-2.0-flash-exp"

# „É¢„Éá„É´Ë®≠ÂÆöËæûÊõ∏
MODEL_CONFIGS = {
    "gemini-2.0-flash-exp": {
        "name": "Gemini 2.0 Flash",
        "model_id": "gemini-2.0-flash-exp",
        "input_cost_per_token": 0.0000001,  # $0.10 per 1M tokens
        "output_cost_per_token": 0.0000004,  # $0.40 per 1M tokens
        "description": "Fast, cost-efficient model with 1M context window",
        "context_window": 1000000,
        "free_tier": True
    },
    "gemini-1.5-flash": {
        "name": "Gemini 1.5 Flash",
        "model_id": "gemini-1.5-flash",
        "input_cost_per_token": 0.0,  # Free
        "output_cost_per_token": 0.0,  # Free
        "description": "Free model with generous rate limits",
        "context_window": 1000000,
        "free_tier": True
    },
    "gemini-1.5-pro": {
        "name": "Gemini 1.5 Pro",
        "model_id": "gemini-1.5-pro",
        "input_cost_per_token": 0.00000125,  # $1.25 per 1M tokens
        "output_cost_per_token": 0.000005,    # $5.00 per 1M tokens
        "description": "High-performance model for complex tasks",
        "context_window": 2000000,
        "free_tier": True
    },
    "gemini-2.5-pro": {
        "name": "Gemini 2.5 Pro",
        "model_id": "gemini-2.5-pro",
        "input_cost_per_token": 0.00000125,  # $1.25 per 1M tokens (up to 200K)
        "output_cost_per_token": 0.00001,     # $10.00 per 1M tokens
        "description": "Most advanced reasoning model",
        "context_window": 2000000,
        "free_tier": False
    }
}

class GeminiEvaluator:
    def __init__(self, api_key: str, model_config: dict):
        self.api_key = api_key
        self.model_config = model_config
        self.token_cache = {}  # „Éà„Éº„ÇØ„É≥Êï∞„Ç≠„É£„ÉÉ„Ç∑„É•
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel(model_config['model_id'])
        
        # count_tokens APIÂà©Áî®ÂèØËÉΩÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        try:
            # „ÉÜ„Çπ„ÉàÂëº„Å≥Âá∫„ÅóÔºàÊ≠£„Åó„ÅÑÂºïÊï∞ÂΩ¢ÂºèÔºâ
            test_result = self.model.count_tokens(["test"])
            self.use_accurate_counting = True
            st.success("‚úÖ Ê≠£Á¢∫„Å™„Éà„Éº„ÇØ„É≥Êï∞ÁÆóÂá∫API„ÅåÂà©Áî®ÂèØËÉΩ„Åß„ÅôÔºÅ")
        except Exception as e:
            self.use_accurate_counting = False
            error_message = str(e)
            
            # „Ç®„É©„Éº„Çø„Ç§„ÉóÂà•„ÅÆÂØæÂøú„É°„ÉÉ„Çª„Éº„Ç∏
            if "API_KEY_INVALID" in error_message or "API key expired" in error_message:
                st.error("üîë **API„Ç≠„Éº„ÅåÁÑ°Âäπ„Åæ„Åü„ÅØÊúüÈôêÂàá„Çå„Åß„Åô**")
                st.markdown("""
                **ÂØæÂá¶ÊñπÊ≥ï:**
                1. [Google AI Studio](https://makersuite.google.com/app/apikey) „ÅßAPI„Ç≠„Éº„ÇíÊõ¥Êñ∞
                2. Êñ∞„Åó„ÅÑAPI„Ç≠„Éº„Çí„Çµ„Ç§„Éâ„Éê„Éº„ÅßÂÖ•Âäõ
                3. „Éö„Éº„Ç∏„ÇíÂÜçË™≠„ÅøËæº„Åø
                """)
            elif "PERMISSION_DENIED" in error_message:
                st.error("üö´ **API„Ç¢„ÇØ„Çª„ÇπÊ®©Èôê„Åå„ÅÇ„Çä„Åæ„Åõ„Çì**")
                st.info("Google AI Studio„Åß„Ç¢„Ç´„Ç¶„É≥„ÉàË®≠ÂÆö„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
            elif "QUOTA_EXCEEDED" in error_message:
                st.error("üìä **API‰ΩøÁî®Èáè‰∏äÈôê„Å´ÈÅî„Åó„Åæ„Åó„Åü**")
                st.info("Google AI Studio„Åß‰ΩøÁî®Èáè„ÇíÁ¢∫Ë™ç„Åô„Çã„Åã„ÄÅÊôÇÈñì„Çí„Åä„ÅÑ„Å¶ÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
            else:
                st.warning(f"‚ö†Ô∏è Ê≠£Á¢∫„Å™„Éà„Éº„ÇØ„É≥Êï∞ÁÆóÂá∫API„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇÊîπËâØ„Åï„Çå„ÅüÊ¶ÇÁÆó„É¢„Éº„Éâ„ÅßÂãï‰Ωú„Åó„Åæ„Åô„ÄÇ")
                st.info(f"Ë©≥Á¥∞„Ç®„É©„Éº: {error_message}")
    
    def count_tokens_accurate(self, text: str) -> int:
        """ÂÖ¨ÂºèAPI„Çí‰ΩøÁî®„Åó„ÅüÊ≠£Á¢∫„Å™„Éà„Éº„ÇØ„É≥Êï∞ÁÆóÂá∫"""
        if not self.use_accurate_counting:
            return self.count_tokens_improved(text)
        
        # „Ç≠„É£„ÉÉ„Ç∑„É•„ÉÅ„Çß„ÉÉ„ÇØ
        text_hash = hashlib.md5(text.encode()).hexdigest()[:8]
        cache_key = f"{self.model_config['model_id']}:{text_hash}"
        
        if cache_key in self.token_cache:
            return self.token_cache[cache_key]
        
        try:
            # Ê≠£„Åó„ÅÑÊßãÊñáÔºö„É™„Çπ„ÉàÂΩ¢Âºè„ÅßÊ∏°„Åô
            result = self.model.count_tokens([text])
            token_count = result.total_tokens
            
            # „Ç≠„É£„ÉÉ„Ç∑„É•„Å´‰øùÂ≠òÔºà„É°„É¢„É™ÁØÄÁ¥Ñ„ÅÆ„Åü„ÇÅÊúÄÊñ∞100‰ª∂„ÅÆ„ÅøÔºâ
            if len(self.token_cache) > 100:
                # Âè§„ÅÑ„Ç®„É≥„Éà„É™„ÇíÂâäÈô§
                oldest_key = next(iter(self.token_cache))
                del self.token_cache[oldest_key]
            
            self.token_cache[cache_key] = token_count
            return token_count
            
        except Exception as e:
            # ÂÆüË°åÊôÇ„Ç®„É©„Éº„ÅØË≠¶Âëä„ÅÆ„ÅøÔºàÂàùÊúüÂåñÊôÇ„Åª„Å©ÈáçË¶Å„Åß„ÅØ„Å™„ÅÑÔºâ
            if not hasattr(self, '_runtime_warning_shown'):
                st.warning(f"Ê≠£Á¢∫„Å™„Éà„Éº„ÇØ„É≥Êï∞ÂèñÂæó„Å´Â§±Êïó„ÄÇÊîπËâØ„Åï„Çå„ÅüÊ¶ÇÁÆóÂÄ§„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ")
                self._runtime_warning_shown = True
            return self.count_tokens_improved(text)
    
    def count_tokens_improved(self, text: str) -> int:
        """ÊîπËâØ„Åï„Çå„ÅüÊ¶ÇÁÆóÊñπÂºèÔºàÂÆüÈöõ„ÅÆ„Éà„Éº„ÇØ„Éä„Ç§„Ç∂„Éº„Å´Ëøë„ÅÑÁ≤æÂ∫¶Ôºâ"""
        
        # „Ç≠„É£„ÉÉ„Ç∑„É•„ÉÅ„Çß„ÉÉ„ÇØ
        text_hash = hashlib.md5(text.encode()).hexdigest()[:8]
        cache_key = f"improved:{text_hash}"
        
        if cache_key in self.token_cache:
            return self.token_cache[cache_key]
        
        # GeminiÂÖ¨Âºè„ÅÆËøë‰ººÂºè: 1„Éà„Éº„ÇØ„É≥ ‚âà 4ÊñáÂ≠ó
        # „Åó„Åã„ÅóË®ÄË™û„ÇÑÂÜÖÂÆπ„Å´„Çà„Å£„Å¶Ë™øÊï¥„ÅåÂøÖË¶Å
        
        char_count = len(text)
        
        # Ë®ÄË™ûÂà•Ë™øÊï¥
        japanese_chars = len(re.findall(r'[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]', text))
        english_words = len(re.findall(r'\b[a-zA-Z]+\b', text))
        punctuation = len(re.findall(r'[^\w\s]', text))
        
        # ÊîπËâØ„Åï„Çå„ÅüË®àÁÆóÂºè
        if japanese_chars > char_count * 0.3:  # Êó•Êú¨Ë™û‰∏≠ÂøÉ
            # Êó•Êú¨Ë™ûÔºö1ÊñáÂ≠ó ‚âà 0.8-1.2„Éà„Éº„ÇØ„É≥
            base_tokens = japanese_chars * 1.0
            base_tokens += english_words * 1.2  # Ëã±ÂçòË™û
            base_tokens += punctuation * 0.5    # Ë®òÂè∑
        else:  # Ëã±Ë™û‰∏≠ÂøÉ
            # Ëã±Ë™ûÔºö1ÂçòË™û ‚âà 1.3„Éà„Éº„ÇØ„É≥„ÄÅ1ÊñáÂ≠ó ‚âà 0.25„Éà„Éº„ÇØ„É≥
            base_tokens = english_words * 1.3
            base_tokens += (char_count - english_words * 5) * 0.25  # ÊÆã„Çä„ÅÆÊñáÂ≠ó
            base_tokens += punctuation * 0.5
        
        # ÊúÄÂ∞èÂÄ§‰øùË®º„Å®„Ç≠„É£„ÉÉ„Ç∑„É•
        token_count = max(1, int(base_tokens))
        
        # „Ç≠„É£„ÉÉ„Ç∑„É•ÁÆ°ÁêÜ
        if len(self.token_cache) > 100:
            oldest_key = next(iter(self.token_cache))
            del self.token_cache[oldest_key]
        
        self.token_cache[cache_key] = token_count
        return token_count
    
    def count_tokens_fallback(self, text: str) -> int:
        """ÂæìÊù•„ÅÆÁ∞°ÊòìË®àÁÆóÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁî®Ôºâ"""
        return len(text.split()) + len(re.findall(r'[^\w\s]', text))
    
    def count_tokens(self, text: str) -> int:
        """„ÉÜ„Ç≠„Çπ„Éà„ÅÆ„Éà„Éº„ÇØ„É≥Êï∞„ÇíÁÆóÂá∫Ôºà„É°„Ç§„É≥Èñ¢Êï∞Ôºâ"""
        return self.count_tokens_accurate(text)
    
    def execute_prompt(self, prompt: str) -> Dict[str, Any]:
        """„Éó„É≠„É≥„Éó„Éà„ÇíÂÆüË°å„Åó„ÄÅÁµêÊûú„Å®„Ç≥„Çπ„ÉàÊÉÖÂ†±„ÇíËøî„Åô"""
        try:
            # Ê≠£Á¢∫„Å™„Éà„Éº„ÇØ„É≥Êï∞ÁÆóÂá∫
            input_tokens = self.count_tokens(prompt)
            
            response = self.model.generate_content(prompt)
            
            # Âá∫Âäõ„Éà„Éº„ÇØ„É≥Êï∞„ÇÇÊ≠£Á¢∫„Å´ÁÆóÂá∫
            output_tokens = self.count_tokens(response.text)
            
            # ÂãïÁöÑÊñôÈáëË®àÁÆó
            input_cost = input_tokens * self.model_config['input_cost_per_token']
            output_cost = output_tokens * self.model_config['output_cost_per_token']
            total_cost = input_cost + output_cost
            
            return {
                'response': response.text,
                'input_tokens': input_tokens,
                'output_tokens': output_tokens,
                'total_tokens': input_tokens + output_tokens,
                'cost_usd': total_cost,
                'model_name': self.model_config['name'],
                'model_id': self.model_config['model_id'],
                'token_accuracy': 'API-Ê≠£Á¢∫' if self.use_accurate_counting else 'Ê¶ÇÁÆó',
                'success': True,
                'error': None
            }
        except Exception as e:
            return {
                'response': None,
                'input_tokens': 0,
                'output_tokens': 0,
                'total_tokens': 0,
                'cost_usd': 0,
                'model_name': self.model_config['name'],
                'model_id': self.model_config['model_id'],
                'token_accuracy': '„Ç®„É©„Éº',
                'success': False,
                'error': str(e)
            }
    
    def evaluate_response(self, original_prompt: str, response: str, evaluation_criteria: str) -> Dict[str, Any]:
        """„É¨„Çπ„Éù„É≥„Çπ„ÇíË©ï‰æ°Âü∫Ê∫ñ„Å´Âü∫„Å•„ÅÑ„Å¶Ë©ï‰æ°"""
        evaluation_prompt = f"""
‰ª•‰∏ã„ÅÆÂÜÖÂÆπ„ÇíË©ï‰æ°„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö

„ÄêÂÖÉ„ÅÆ„Éó„É≠„É≥„Éó„Éà„Äë
{original_prompt}

„ÄêLLM„ÅÆÂõûÁ≠î„Äë
{response}

„ÄêË©ï‰æ°Âü∫Ê∫ñ„Äë
{evaluation_criteria}

„ÄêË©ï‰æ°ÊåáÁ§∫„Äë
‰∏äË®ò„ÅÆË©ï‰æ°Âü∫Ê∫ñ„Å´Âü∫„Å•„ÅÑ„Å¶„ÄÅLLM„ÅÆÂõûÁ≠î„ÇíË©≥Á¥∞„Å´Ë©ï‰æ°„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
‰ª•‰∏ã„ÅÆÂΩ¢Âºè„ÅßÂõûÁ≠î„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö

1. Á∑èÂêàË©ï‰æ°: [1-10ÁÇπ„ÅÆÊï∞ÂÄ§Ë©ï‰æ°]
2. ÂêÑÈ†ÖÁõÆ„ÅÆË©ï‰æ°: [Ë©ï‰æ°Âü∫Ê∫ñ„ÅÆÂêÑÈ†ÖÁõÆ„Å´„Å§„ÅÑ„Å¶Ë©≥Á¥∞Ë©ï‰æ°]
3. ËâØ„ÅÑÁÇπ: [ÂÖ∑‰ΩìÁöÑ„Å™ËâØ„ÅÑÁÇπ]
4. ÊîπÂñÑÁÇπ: [ÂÖ∑‰ΩìÁöÑ„Å™ÊîπÂñÑ„Åô„Åπ„ÅçÁÇπ]
5. Á∑èÂêà„Ç≥„É°„É≥„Éà: [ÂÖ®‰ΩìÁöÑ„Å™Ë©ï‰æ°„Ç≥„É°„É≥„Éà]
"""
        
        return self.execute_prompt(evaluation_prompt)

def format_timestamp(timestamp):
    """„Çø„Ç§„É†„Çπ„Çø„É≥„Éó„Çí„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÔºàÊñáÂ≠óÂàó„Éªdatetime‰∏°ÂØæÂøúÔºâ"""
    if isinstance(timestamp, str):
        # ÊñáÂ≠óÂàó„ÅÆÂ†¥Âêà„ÅØ„Åù„ÅÆ„Åæ„ÅæËøî„ÅôÔºàJSON„Åã„ÇâË™≠„ÅøËæº„Çì„Å†Â†¥ÂêàÔºâ
        if 'T' in timestamp:
            # ISOÂΩ¢Âºè„ÅÆÂ†¥Âêà„ÅØË¶ã„ÇÑ„Åô„ÅèÂ§âÊèõ
            try:
                dt = datetime.datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
                return dt.strftime('%Y-%m-%d %H:%M:%S')
            except:
                return timestamp[:19]  # ÊúÄÂàù„ÅÆ19ÊñáÂ≠ó„ÇíÂèñÂæó
        return timestamp
    else:
        # datetime „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂ†¥Âêà
        return timestamp.strftime('%Y-%m-%d %H:%M:%S')

def generate_commit_hash(content: str) -> str:
    """„Ç≥„É≥„ÉÜ„É≥„ÉÑ„Åã„Çâ„Ç≥„Éü„ÉÉ„Éà„Éè„ÉÉ„Ç∑„É•„ÇíÁîüÊàê"""
    return hashlib.md5(content.encode()).hexdigest()[:8]

def get_diff_html(old_text: str, new_text: str) -> str:
    """2„Å§„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÅÆÂ∑ÆÂàÜ„ÇíHTML„ÅßË°®Á§∫"""
    old_lines = old_text.splitlines()
    new_lines = new_text.splitlines()
    
    diff = list(difflib.unified_diff(old_lines, new_lines, lineterm=''))
    
    if not diff:
        return "Â§âÊõ¥„Å™„Åó"
    
    html_diff = []
    for line in diff[3:]:  # „Éò„ÉÉ„ÉÄ„ÉºË°å„Çí„Çπ„Ç≠„ÉÉ„Éó
        if line.startswith('+'):
            html_diff.append(f'<div class="diff-added">+ {html.escape(line[1:])}</div>')
        elif line.startswith('-'):
            html_diff.append(f'<div class="diff-removed">- {html.escape(line[1:])}</div>')
        else:
            html_diff.append(f'<div>{html.escape(line)}</div>')
    
    return ''.join(html_diff)

def create_commit(data: Dict[str, Any], execution_memo: str) -> Dict[str, Any]:
    """Êñ∞„Åó„ÅÑÂÆüË°åË®òÈå≤„Çí‰ΩúÊàê"""
    commit_hash = generate_commit_hash(str(data))
    
    execution_record = {
        **data,
        'commit_hash': commit_hash,
        'commit_message': execution_memo,
        'branch': st.session_state.current_branch,
        'parent_hash': None
    }
    
    # Ë¶™Ë®òÈå≤„ÅÆ„Éè„ÉÉ„Ç∑„É•„ÇíË®≠ÂÆö
    current_branch_executions = st.session_state.branches[st.session_state.current_branch]
    if current_branch_executions:
        execution_record['parent_hash'] = current_branch_executions[-1]['commit_hash']
    
    return execution_record

def main():
    # „É°„Ç§„É≥„Çø„Ç§„Éà„É´
    st.title("üöÄ LLM „Éó„É≠„É≥„Éó„Éà Git ÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†")
    st.markdown("GitÈ¢®„ÅÆ„Éê„Éº„Ç∏„Éß„É≥ÁÆ°ÁêÜ„Åß„Éó„É≠„É≥„Éó„Éà„ÅÆÈÄ≤Âåñ„ÇíËøΩË∑°„Åó„Åæ„Åó„Çá„ÅÜÔºÅ")
    
    # GitÊÉÖÂ†±Ë°®Á§∫
    col1, col2, col3 = st.columns([2, 1, 1])
    with col1:
        st.markdown(f"**üìç ÁèæÂú®„ÅÆ„Éñ„É©„É≥„ÉÅ:** `{st.session_state.current_branch}`")
    with col2:
        total_executions = len(st.session_state.evaluation_history)
        st.markdown(f"**üìù Á∑èÂÆüË°åÊï∞:** {total_executions}")
    with col3:
        total_branches = len(st.session_state.branches)
        st.markdown(f"**üåø „Éñ„É©„É≥„ÉÅÊï∞:** {total_branches}")
    
    # GitÊÉÖÂ†±Ë°®Á§∫„ÅÆ‰∏ã„Å´Ë™¨Êòé„ÇíËøΩÂä†
    st.info("üí° GitÈ¢®„ÅÆÂ±•Ê≠¥ÁÆ°ÁêÜ„Åß„Éó„É≠„É≥„Éó„Éà„ÅÆÊîπÂñÑÈÅéÁ®ã„ÇíËøΩË∑°„Åß„Åç„Åæ„Åô„ÄÇÂÆüË°å„É°„É¢„ÅßÂ§âÊõ¥ÁêÜÁî±„ÇíË®òÈå≤„Åó„ÄÅ„Éñ„É©„É≥„ÉÅ„ÅßÁï∞„Å™„Çã„Ç¢„Éó„É≠„Éº„ÉÅ„Çí‰∏¶Ë°å„ÉÜ„Çπ„Éà„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ")
    
    st.markdown("---")
    
    # „Çµ„Ç§„Éâ„Éê„Éº
    with st.sidebar:
        st.header("‚öôÔ∏è Ë®≠ÂÆö")
        
        api_key = st.text_input(
            "üîë Gemini API Key", 
            value=st.session_state.api_key,
            type="password",
            help="Google AI Studio„ÅßAPI„Ç≠„Éº„ÇíÂèñÂæó„Åó„Å¶„Åè„Å†„Åï„ÅÑ"
        )
        
        if api_key != st.session_state.api_key:
            st.session_state.api_key = api_key
        
        if not api_key:
            st.error("‚ö†Ô∏è API„Ç≠„Éº„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
            st.stop()
        
        # „É¢„Éá„É´ÈÅ∏Êäû
        st.subheader("ü§ñ „É¢„Éá„É´ÈÅ∏Êäû")
        
        model_options = list(MODEL_CONFIGS.keys())
        
        selected_model_index = model_options.index(st.session_state.selected_model) if st.session_state.selected_model in model_options else 0
        
        selected_model = st.selectbox(
            "‰ΩøÁî®„Åô„Çã„É¢„Éá„É´",
            model_options,
            format_func=lambda x: MODEL_CONFIGS[x]['name'],
            index=selected_model_index
        )
        
        if selected_model != st.session_state.selected_model:
            st.session_state.selected_model = selected_model
        
        # ÈÅ∏Êäû„Åï„Çå„Åü„É¢„Éá„É´„ÅÆË©≥Á¥∞ÊÉÖÂ†±
        current_model = MODEL_CONFIGS[st.session_state.selected_model]
        
        st.markdown(f"""
        **üìã „É¢„Éá„É´Ë©≥Á¥∞:**
        - **ÂêçÂâç**: {current_model['name']}
        - **Ë™¨Êòé**: {current_model['description']}
        - **„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà**: {current_model['context_window']:,} tokens
        - **ÁÑ°ÊñôÊû†**: {'‚úÖ „ÅÇ„Çä' if current_model['free_tier'] else '‚ùå „Å™„Åó'}
        """)
        
        # ÊñôÈáëÊÉÖÂ†±
        if current_model['input_cost_per_token'] == 0 and current_model['output_cost_per_token'] == 0:
            st.success("üí∞ **ÂÆåÂÖ®ÁÑ°Êñô!**")
        else:
            st.markdown(f"""
            **üí∞ ÊñôÈáë:**
            - ÂÖ•Âäõ: ${current_model['input_cost_per_token'] * 1000000:.2f}/1M tokens
            - Âá∫Âäõ: ${current_model['output_cost_per_token'] * 1000000:.2f}/1M tokens
            """)
        
        st.markdown("---")
        
        # „Éá„Éº„ÇøÁÆ°ÁêÜ
        st.header("üíæ „Éá„Éº„ÇøÁÆ°ÁêÜ")
        
        # Â±•Ê≠¥‰øùÂ≠ò
        if st.session_state.evaluation_history:
            history_data = {
                'evaluation_history': st.session_state.evaluation_history,
                'branches': st.session_state.branches,
                'tags': st.session_state.tags,
                'current_branch': st.session_state.current_branch,
                'export_timestamp': datetime.datetime.now().isoformat()
            }
            
            history_json = json.dumps(history_data, default=str, ensure_ascii=False, indent=2)
            
            st.download_button(
                label="üíæ Â±•Ê≠¥„Çí„É≠„Éº„Ç´„É´‰øùÂ≠ò",
                data=history_json,
                file_name=f"prompt_history_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
                mime="application/json",
                help="ÂÆüË°åÂ±•Ê≠¥„ÇíJSON„Éï„Ç°„Ç§„É´„Å®„Åó„Å¶„É≠„Éº„Ç´„É´„Å´‰øùÂ≠ò„Åó„Åæ„Åô"
            )
        
        # Â±•Ê≠¥Ë™≠„ÅøËæº„Åø
        st.subheader("üìÇ Â±•Ê≠¥Ë™≠„ÅøËæº„Åø")
        
        uploaded_file = st.file_uploader(
            "Â±•Ê≠¥„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû",
            type=["json", "csv"],
            help="JSON„Éï„Ç°„Ç§„É´ÔºàÂÆåÂÖ®Âæ©ÂÖÉÔºâ„Åæ„Åü„ÅØCSV„Éï„Ç°„Ç§„É´ÔºàÂü∫Êú¨„Éá„Éº„Çø„ÅÆ„ÅøÔºâ„ÇíË™≠„ÅøËæº„Åø„Åæ„Åô"
        )
        
        if uploaded_file is not None:
            file_extension = uploaded_file.name.split('.')[-1].lower()
            
            try:
                if file_extension == 'json':
                    # JSONË™≠„ÅøËæº„Åø
                    history_data = json.load(uploaded_file)
                    
                    if st.button("üì• JSONÂ±•Ê≠¥„ÇíÂæ©ÂÖÉ"):
                        # „Éá„Éº„Çø„ÇíÂæ©ÂÖÉÔºà„Çø„Ç§„É†„Çπ„Çø„É≥„Éó„ÅØ„Åù„ÅÆ„Åæ„ÅæÊñáÂ≠óÂàó„Å®„Åó„Å¶‰øùÊåÅÔºâ
                        st.session_state.evaluation_history = history_data.get('evaluation_history', [])
                        st.session_state.branches = history_data.get('branches', {"main": []})
                        st.session_state.tags = history_data.get('tags', {})
                        st.session_state.current_branch = history_data.get('current_branch', 'main')
                        
                        st.success("‚úÖ JSONÂ±•Ê≠¥„ÇíÂæ©ÂÖÉ„Åó„Åæ„Åó„ÅüÔºÅ")
                        st.rerun()
                    
                    # „Éó„É¨„Éì„É•„ÉºÊÉÖÂ†±
                    total_records = len(history_data.get('evaluation_history', []))
                    export_time = history_data.get('export_timestamp', 'Unknown')
                    if 'T' in str(export_time):
                        export_time = format_timestamp(export_time)
                    st.info(f"üìä {total_records}‰ª∂„ÅÆË®òÈå≤\nüìÖ {export_time}")
                
                elif file_extension == 'csv':
                    # CSVË™≠„ÅøËæº„Åø
                    df = pd.read_csv(uploaded_file)
                    
                    if st.button("üì• CSVÂ±•Ê≠¥„Çí„Ç§„É≥„Éù„Éº„Éà"):
                        # CSV„Éá„Éº„Çø„ÇíÂÜÖÈÉ®ÂΩ¢Âºè„Å´Â§âÊèõ
                        imported_records = []
                        current_branch = st.session_state.current_branch
                        
                        for _, row in df.iterrows():
                            record = {
                                'timestamp': row.get('timestamp', datetime.datetime.now().isoformat()),
                                'execution_mode': row.get('execution_mode', 'Âçò‰∏Ä„Éó„É≠„É≥„Éó„Éà'),
                                'prompt_template': row.get('prompt_template', None),
                                'user_input': row.get('user_input', None),
                                'final_prompt': row.get('final_prompt', ''),
                                'criteria': row.get('criteria', ''),
                                'response': row.get('response', ''),
                                'evaluation': row.get('evaluation', ''),
                                'execution_tokens': int(row.get('execution_tokens', 0)),
                                'evaluation_tokens': int(row.get('evaluation_tokens', 0)),
                                'execution_cost': float(row.get('execution_cost', 0.0)),
                                'evaluation_cost': float(row.get('evaluation_cost', 0.0)),
                                'total_cost': float(row.get('total_cost', 0.0)),
                                'commit_hash': row.get('commit_hash', generate_commit_hash(str(row.to_dict()))),
                                'commit_message': row.get('commit_message', 'CSV„Ç§„É≥„Éù„Éº„Éà'),
                                'branch': row.get('branch', current_branch),
                                'parent_hash': row.get('parent_hash', None)
                            }
                            imported_records.append(record)
                        
                        # Êó¢Â≠ò„Éá„Éº„Çø„Å´ËøΩÂä†
                        st.session_state.evaluation_history.extend(imported_records)
                        
                        # „Éñ„É©„É≥„ÉÅÂà•„Å´Êï¥ÁêÜ
                        for record in imported_records:
                            branch_name = record['branch']
                            if branch_name not in st.session_state.branches:
                                st.session_state.branches[branch_name] = []
                            st.session_state.branches[branch_name].append(record)
                        
                        st.success(f"‚úÖ CSVÂ±•Ê≠¥„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„Åæ„Åó„ÅüÔºÅÔºà{len(imported_records)}‰ª∂Ôºâ")
                        st.rerun()
                    
                    # CSV„Éó„É¨„Éì„É•„ÉºÊÉÖÂ†±
                    st.info(f"üìä {len(df)}‰ª∂„ÅÆË®òÈå≤\nüìã ÂàóÊï∞: {len(df.columns)}")
                    
                    # „Éá„Éº„Çø„Éó„É¨„Éì„É•„Éº
                    if st.checkbox("üîç CSV„Éá„Éº„Çø„Çí„Éó„É¨„Éì„É•„Éº"):
                        st.dataframe(df.head(), use_container_width=True)
                
            except Exception as e:
                st.error(f"‚ùå „Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº: {str(e)}")
        
        # „Éá„Éº„Çø„ÇØ„É™„Ç¢
        if st.session_state.evaluation_history:
            st.markdown("---")
            if st.button("üóëÔ∏è ÂÖ®„Éá„Éº„Çø„ÇØ„É™„Ç¢", type="secondary"):
                if st.button("‚ö†Ô∏è Êú¨ÂΩì„Å´„ÇØ„É™„Ç¢„Åó„Åæ„Åô„ÅãÔºü", type="secondary"):
                    st.session_state.evaluation_history = []
                    st.session_state.branches = {"main": []}
                    st.session_state.tags = {}
                    st.session_state.current_branch = "main"
                    st.success("‚úÖ „Éá„Éº„Çø„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åó„Åü")
                    st.rerun()
        
        st.markdown("---")
        
        # GitÊìç‰Ωú
        st.header("üåø „Éñ„É©„É≥„ÉÅÁÆ°ÁêÜ")
        
        # ÁèæÂú®„ÅÆ„Éñ„É©„É≥„ÉÅÈÅ∏Êäû
        available_branches = list(st.session_state.branches.keys())
        current_branch_index = available_branches.index(st.session_state.current_branch)
        
        selected_branch = st.selectbox(
            "„Éñ„É©„É≥„ÉÅ„ÇíÈÅ∏Êäû",
            available_branches,
            index=current_branch_index
        )
        
        if selected_branch != st.session_state.current_branch:
            st.session_state.current_branch = selected_branch
            st.rerun()
        
        # Êñ∞„Åó„ÅÑ„Éñ„É©„É≥„ÉÅ‰ΩúÊàê
        new_branch_name = st.text_input("Êñ∞„Åó„ÅÑ„Éñ„É©„É≥„ÉÅÂêç")
        if st.button("üå± „Éñ„É©„É≥„ÉÅ‰ΩúÊàê"):
            if new_branch_name and new_branch_name not in st.session_state.branches:
                # ÁèæÂú®„ÅÆ„Éñ„É©„É≥„ÉÅ„Åã„Çâ„Ç≥„Éî„Éº
                st.session_state.branches[new_branch_name] = st.session_state.branches[st.session_state.current_branch].copy()
                st.session_state.current_branch = new_branch_name  # Êñ∞„Åó„ÅÑ„Éñ„É©„É≥„ÉÅ„Å´Ëá™ÂãïÂàá„ÇäÊõø„Åà
                st.success(f"„Éñ„É©„É≥„ÉÅ '{new_branch_name}' „Çí‰ΩúÊàê„Åó„ÄÅÂàá„ÇäÊõø„Åà„Åæ„Åó„Åü")
                st.rerun()  # ÁîªÈù¢„ÇíÊõ¥Êñ∞
            elif new_branch_name in st.session_state.branches:
                st.error("ÂêåÂêç„ÅÆ„Éñ„É©„É≥„ÉÅ„ÅåÊó¢„Å´Â≠òÂú®„Åó„Åæ„Åô")
            elif not new_branch_name:
                st.warning("„Éñ„É©„É≥„ÉÅÂêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
        
        st.markdown("---")
        
        # „Çø„Ç∞ÁÆ°ÁêÜ
        st.header("üè∑Ô∏è „Çø„Ç∞ÁÆ°ÁêÜ")
        
        if st.session_state.evaluation_history:
            execution_options = [f"{execution['commit_hash']} - {execution.get('commit_message', '„É°„É¢„Å™„Åó')}" 
                            for execution in st.session_state.evaluation_history]
            
            selected_execution_idx = st.selectbox("„Çø„Ç∞„Çí‰ªò„Åë„ÇãÂÆüË°åË®òÈå≤", 
                                             range(len(execution_options)), 
                                             format_func=lambda x: execution_options[x])
            
            tag_name = st.text_input("„Çø„Ç∞Âêç")
            if st.button("üè∑Ô∏è „Çø„Ç∞‰ΩúÊàê"):
                if tag_name and tag_name not in st.session_state.tags:
                    exec_hash = st.session_state.evaluation_history[selected_execution_idx]['commit_hash']
                    st.session_state.tags[tag_name] = exec_hash
                    st.success(f"„Çø„Ç∞ '{tag_name}' „Çí‰ΩúÊàê„Åó„Åæ„Åó„Åü")
                elif tag_name in st.session_state.tags:
                    st.error("ÂêåÂêç„ÅÆ„Çø„Ç∞„ÅåÊó¢„Å´Â≠òÂú®„Åó„Åæ„Åô")
        
        st.markdown("---")
        
        # Áµ±Ë®àÊÉÖÂ†±
        if st.session_state.evaluation_history:
            st.header("üìä Áµ±Ë®àÊÉÖÂ†±")
            
            branch_executions = st.session_state.branches[st.session_state.current_branch]
            total_cost = sum([execution['execution_cost'] for execution in branch_executions])  # ÂÆüË°å„Ç≥„Çπ„Éà„ÅÆ„Åø
            total_tokens = sum([execution['execution_tokens'] + execution['evaluation_tokens'] 
                              for execution in branch_executions])
            
            st.metric("„Éñ„É©„É≥„ÉÅÂÜÖÂÆüË°åÊï∞", len(branch_executions))
            st.metric("„Éñ„É©„É≥„ÉÅÂÜÖÂÆüË°å„Ç≥„Çπ„Éà", f"${total_cost:.6f}")
            st.metric("„Éñ„É©„É≥„ÉÅÂÜÖÁ∑è„Éà„Éº„ÇØ„É≥", f"{total_tokens:,}")
    
    # „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑ
    tab1, tab2, tab3, tab4 = st.tabs(["üöÄ Êñ∞Ë¶èÂÆüË°å", "üìã ÂÆüË°åÂ±•Ê≠¥", "üîç ÁµêÊûúÊØîËºÉ", "üåø „Éñ„É©„É≥„ÉÅË¶ñË¶öÂåñ"])
    
    with tab1:
        st.header("Êñ∞„Åó„ÅÑ„Éó„É≠„É≥„Éó„Éà„ÇíÂÆüË°å")
        
        # ÂÆüË°å„É°„É¢
        execution_memo = st.text_input(
            "üìù ÂÆüË°å„É°„É¢",
            placeholder="„Éó„É≠„É≥„Éó„Éà„ÅÆÂ§âÊõ¥ÂÜÖÂÆπ„ÇÑÂÆüÈ®ì„ÅÆÁõÆÁöÑ„ÇíË®òÈå≤„Åó„Å¶„Åè„Å†„Åï„ÅÑ...",
            help="„Åì„ÅÆÂÆüË°å„ÅÆÁõÆÁöÑ„ÇÑÂ§âÊõ¥ÁÇπ„ÇíË®òÈå≤„Åó„Åæ„ÅôÔºàGitÈ¢®„ÅÆÂ±•Ê≠¥ÁÆ°ÁêÜÔºâ"
        )
        
        # ÂÆüË°å„É¢„Éº„ÉâÈÅ∏Êäû
        st.subheader("üìã ÂÆüË°å„É¢„Éº„ÉâÈÅ∏Êäû")
        execution_mode = st.radio(
            "ÂÆüË°åÊñπÊ≥ï„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
            ["„ÉÜ„É≥„Éó„É¨„Éº„Éà + „Éá„Éº„ÇøÂÖ•Âäõ", "Âçò‰∏Ä„Éó„É≠„É≥„Éó„Éà"],
            horizontal=True
        )
        
        st.markdown("---")
        
        # „Éó„É≠„É≥„Éó„ÉàË®≠ÂÆö
        st.subheader("üìù „Éó„É≠„É≥„Éó„ÉàË®≠ÂÆö")
        
        if execution_mode == "„ÉÜ„É≥„Éó„É¨„Éº„Éà + „Éá„Éº„ÇøÂÖ•Âäõ":
            col1, col2 = st.columns(2)
            
            with col1:
                st.write("**üîß „Éó„É≠„É≥„Éó„Éà„ÉÜ„É≥„Éó„É¨„Éº„Éà**")
                prompt_template = st.text_area(
                    "„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÇíÂÖ•Âäõ",
                    height=200,
                    placeholder="""‰æãÔºö‰ª•‰∏ã„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÇíË¶ÅÁ¥Ñ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö

{user_input}

Ë¶ÅÁ¥Ñ„ÅØ3„Å§„ÅÆË¶ÅÁÇπ„Å´„Åæ„Å®„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ""",
                    help="{user_input}„Åß„É¶„Éº„Ç∂„ÉºÂÖ•Âäõ„ÇíÂèÇÁÖß„Åß„Åç„Åæ„Åô",
                    key="template"
                )
            
            with col2:
                st.write("**üìä Âá¶ÁêÜ„Éá„Éº„Çø**")
                user_input = st.text_area(
                    "Âá¶ÁêÜ„Åó„Åü„ÅÑ„Éá„Éº„Çø„ÇíÂÖ•Âäõ",
                    height=200,
                    placeholder="„Åì„Åì„Å´Âá¶ÁêÜ„Åó„Åü„ÅÑ„Éá„Éº„Çø„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ...",
                    key="user_data"
                )
            
            # „Éó„É¨„Éì„É•„Éº
            if prompt_template and user_input and "{user_input}" in prompt_template:
                final_prompt = prompt_template.replace("{user_input}", user_input)
                st.success("‚úÖ „Éó„É≠„É≥„Éó„Éà„ÅåÊ≠£Â∏∏„Å´ÁµêÂêà„Åï„Çå„Åæ„Åó„Åü")
                
                if st.checkbox("üîç ÊúÄÁµÇ„Éó„É≠„É≥„Éó„Éà„Çí„Éó„É¨„Éì„É•„Éº"):
                    st.code(final_prompt, language=None)
                    
            elif prompt_template and "{user_input}" not in prompt_template:
                st.warning("‚ö†Ô∏è „Éó„É≠„É≥„Éó„Éà„ÉÜ„É≥„Éó„É¨„Éº„Éà„Å´{user_input}„ÇíÂê´„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ")
                final_prompt = None
            else:
                final_prompt = None
                
        else:
            st.write("**üìù Âçò‰∏Ä„Éó„É≠„É≥„Éó„Éà**")
            final_prompt = st.text_area(
                "„Éó„É≠„É≥„Éó„Éà„ÇíÂÖ•Âäõ",
                height=200,
                placeholder="Ë©ï‰æ°„Åó„Åü„ÅÑ„Éó„É≠„É≥„Éó„Éà„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ...",
                key="single_prompt"
            )
            prompt_template = None
            user_input = None
        
        st.markdown("---")
        
        # Ë©ï‰æ°Âü∫Ê∫ñ
        st.subheader("üìã Ë©ï‰æ°Âü∫Ê∫ñË®≠ÂÆö")
        evaluation_criteria = st.text_area(
            "Ë©ï‰æ°Âü∫Ê∫ñ„ÇíÂÖ•Âäõ",
            height=150,
            value="""1. ÂõûÁ≠î„ÅÆÊ≠£Á¢∫ÊÄßÔºà30ÁÇπÔºâ
2. ÊÉÖÂ†±„ÅÆÁ∂≤ÁæÖÊÄßÔºà25ÁÇπÔºâ
3. Ë™¨Êòé„ÅÆÂàÜ„Åã„Çä„ÇÑ„Åô„ÅïÔºà25ÁÇπÔºâ
4. ÊßãÊàê„ÅÆË´ñÁêÜÊÄßÔºà20ÁÇπÔºâ""",
            help="LLM„ÅÆÂõûÁ≠î„Çí„Å©„ÅÆ„Çà„ÅÜ„Å™Âü∫Ê∫ñ„ÅßË©ï‰æ°„Åô„Çã„Åã„ÇíË®òËºâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
            key="criteria"
        )
        
        st.markdown("---")
        
        # ÂÆüË°å„Éú„Çø„É≥
        if st.button("üöÄ ÂÆüË°å & Â±•Ê≠¥„Å´Ë®òÈå≤", type="primary"):
            if not execution_memo:
                st.error("‚ùå ÂÆüË°å„É°„É¢„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
                return
            
            if not final_prompt:
                st.error("‚ùå „Éó„É≠„É≥„Éó„Éà„ÇíÊ≠£„Åó„ÅèË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
                return
            
            if not evaluation_criteria:
                st.error("‚ùå Ë©ï‰æ°Âü∫Ê∫ñ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
                return
            
            # ÂÆüË°å
            current_model_config = MODEL_CONFIGS[st.session_state.selected_model]
            evaluator = GeminiEvaluator(st.session_state.api_key, current_model_config)
            
            # „Éó„É≠„É≥„Éó„ÉàÂÆüË°å
            with st.spinner(f"üîÑ {current_model_config['name']}„Åß„Éó„É≠„É≥„Éó„ÉàÂÆüË°å‰∏≠..."):
                execution_result = evaluator.execute_prompt(final_prompt)
            
            if not execution_result['success']:
                st.error(f"‚ùå „Éó„É≠„É≥„Éó„ÉàÂÆüË°å„Ç®„É©„Éº: {execution_result['error']}")
                return
            
            # Ë©ï‰æ°ÂÆüË°å
            with st.spinner("üìä Ë©ï‰æ°‰∏≠..."):
                evaluation_result = evaluator.evaluate_response(
                    final_prompt, 
                    execution_result['response'], 
                    evaluation_criteria
                )
            
            if not evaluation_result['success']:
                st.error(f"‚ùå Ë©ï‰æ°„Ç®„É©„Éº: {evaluation_result['error']}")
                return
            
            # ÂÆüË°åË®òÈå≤‰ΩúÊàê
            execution_data = {
                'timestamp': datetime.datetime.now(),
                'execution_mode': execution_mode,
                'prompt_template': prompt_template,
                'user_input': user_input,
                'final_prompt': final_prompt,
                'criteria': evaluation_criteria,
                'response': execution_result['response'],
                'evaluation': evaluation_result['response'],
                'execution_tokens': execution_result['total_tokens'],
                'evaluation_tokens': evaluation_result['total_tokens'],
                'execution_cost': execution_result['cost_usd'],
                'evaluation_cost': evaluation_result['cost_usd'],
                'total_cost': execution_result['cost_usd'],  # ÂÆüË°å„Ç≥„Çπ„Éà„ÅÆ„Åø
                'model_name': execution_result['model_name'],
                'model_id': execution_result['model_id'],
                'token_accuracy': execution_result.get('token_accuracy', '‰∏çÊòé')
            }
            
            execution_record = create_commit(execution_data, execution_memo)
            
            # Â±•Ê≠¥„Å®„Éñ„É©„É≥„ÉÅ„Å´ËøΩÂä†
            st.session_state.evaluation_history.append(execution_record)
            st.session_state.branches[st.session_state.current_branch].append(execution_record)
            
            # ÁµêÊûúË°®Á§∫
            accuracy_icon = "‚úÖ" if execution_result.get('token_accuracy') == 'API-Ê≠£Á¢∫' else "‚ö†Ô∏è"
            st.success(f"‚úÖ ÂÆüË°åÂÆå‰∫ÜÔºÅ‰ΩøÁî®„É¢„Éá„É´: {execution_result['model_name']}")
            st.info(f"üîó ÂÆüË°åID: `{execution_record['commit_hash']}` | {accuracy_icon} „Éà„Éº„ÇØ„É≥Á≤æÂ∫¶: {execution_result.get('token_accuracy', '‰∏çÊòé')}")
            st.markdown("---")
            
            # 1. LLM„ÅÆÂõûÁ≠îÔºàÊúÄÂÑ™ÂÖàË°®Á§∫Ôºâ
            st.subheader("ü§ñ LLM„ÅÆÂõûÁ≠î")
            st.markdown(f"""
            <div style="background: #ffffff; color: #2c3e50; padding: 2rem; border-radius: 10px; border-left: 4px solid #667eea; margin: 1rem 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <p style="color: #2c3e50; line-height: 1.6; margin: 0;">{html.escape(execution_result['response']).replace(chr(10), '<br>')}</p>
            </div>
            """, unsafe_allow_html=True)
            
            # 2. Ë©ï‰æ°ÁµêÊûú
            st.subheader("‚≠ê Ë©ï‰æ°ÁµêÊûú")
            st.markdown(f"""
            <div style="background: #ffffff; color: #2c3e50; padding: 2rem; border-radius: 10px; border-left: 4px solid #f5576c; margin: 1rem 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <p style="color: #2c3e50; line-height: 1.6; margin: 0;">{html.escape(evaluation_result['response']).replace(chr(10), '<br>')}</p>
            </div>
            """, unsafe_allow_html=True)
            
            # 3. „Ç≥„Çπ„ÉàÊÉÖÂ†±
            st.subheader("üí∞ „Ç≥„Çπ„ÉàÊÉÖÂ†±")
            
            cost_col1, cost_col2, cost_col3 = st.columns(3)
            
            with cost_col1:
                st.markdown(f"""
                <div style="background: #ffffff; color: #2c3e50; padding: 1rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center; border: 1px solid #e0e0e0;">
                    <h4 style="color: #2c3e50; margin: 0 0 0.5rem 0;">ÂÆüË°å„Ç≥„Çπ„Éà</h4>
                    <h2 style="color: #667eea; margin: 0.5rem 0;">${execution_result['cost_usd']:.6f}</h2>
                    <p style="color: #666; margin: 0;">„Éà„Éº„ÇØ„É≥: {execution_result['total_tokens']:,}</p>
                </div>
                """, unsafe_allow_html=True)
            
            with cost_col2:
                st.markdown(f"""
                <div style="background: #ffffff; color: #2c3e50; padding: 1rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center; border: 1px solid #e0e0e0;">
                    <h4 style="color: #2c3e50; margin: 0 0 0.5rem 0;">Ë©ï‰æ°„Ç≥„Çπ„ÉàÔºàÂèÇËÄÉÔºâ</h4>
                    <h2 style="color: #f5576c; margin: 0.5rem 0;">${evaluation_result['cost_usd']:.6f}</h2>
                    <p style="color: #666; margin: 0;">„Éà„Éº„ÇØ„É≥: {evaluation_result['total_tokens']:,}</p>
                </div>
                """, unsafe_allow_html=True)
            
            with cost_col3:
                st.markdown(f"""
                <div style="background: #ffffff; color: #2c3e50; padding: 1rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center; border: 1px solid #e0e0e0;">
                    <h4 style="color: #2c3e50; margin: 0 0 0.5rem 0;">Á∑è„Ç≥„Çπ„ÉàÔºàÂÆüË°å„ÅÆ„ÅøÔºâ</h4>
                    <h2 style="color: #4caf50; margin: 0.5rem 0;">${execution_data['total_cost']:.6f}</h2>
                    <p style="color: #666; margin: 0;">ÂÆüË°å„Éà„Éº„ÇØ„É≥: {execution_data['execution_tokens']:,}</p>
                </div>
                """, unsafe_allow_html=True)
    
    with tab2:
        st.header("üìã ÂÆüË°åÂ±•Ê≠¥")
        
        # „Éñ„É©„É≥„ÉÅ„Éï„Ç£„É´„Çø„Éº
        col1, col2 = st.columns([3, 1])
        with col1:
            show_all_branches = st.checkbox("ÂÖ®„Éñ„É©„É≥„ÉÅË°®Á§∫", value=False)
        with col2:
            if st.button("üì• Â±•Ê≠¥„Ç®„ÇØ„Çπ„Éù„Éº„Éà"):
                df = pd.DataFrame(st.session_state.evaluation_history)
                csv = df.to_csv(index=False, encoding='utf-8-sig')
                st.download_button(
                    label="CSV „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ",
                    data=csv,
                    file_name=f"prompt_execution_history_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                    mime="text/csv"
                )
        
        # Ë°®Á§∫„Åô„ÇãÂÆüË°åË®òÈå≤„ÇíÈÅ∏Êäû
        if show_all_branches:
            executions_to_show = st.session_state.evaluation_history
        else:
            executions_to_show = st.session_state.branches[st.session_state.current_branch]
        
        if not executions_to_show:
            st.info("„Åæ„Å†ÂÆüË°åÂ±•Ê≠¥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ„ÄåÊñ∞Ë¶èÂÆüË°å„Äç„Çø„Éñ„Åß„Éó„É≠„É≥„Éó„Éà„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
            return
        
        st.markdown("---")
        
        # ÂÆüË°åÂ±•Ê≠¥Ë°®Á§∫
        for i, execution in enumerate(reversed(executions_to_show)):
            timestamp = format_timestamp(execution['timestamp'])
            exec_hash = execution['commit_hash']
            exec_memo = execution.get('commit_message', '„É°„É¢„Å™„Åó')
            branch = execution.get('branch', 'unknown')
            model_name = execution.get('model_name', 'Unknown Model')
            token_accuracy = execution.get('token_accuracy', '‰∏çÊòé')
            
            # Á≤æÂ∫¶„Ç¢„Ç§„Ç≥„É≥
            accuracy_icon = "‚úÖ" if token_accuracy == 'API-Ê≠£Á¢∫' else "‚ö†Ô∏è" if token_accuracy == 'Ê¶ÇÁÆó' else "‚ùì"
            
            # „Çø„Ç∞„ÉÅ„Çß„ÉÉ„ÇØ
            tags_for_execution = [tag for tag, hash_val in st.session_state.tags.items() if hash_val == exec_hash]
            
            # ÂÆüË°å„Ç´„Éº„Éâ
            st.markdown(f"""
            <div class="commit-card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                    <div>
                        <span class="branch-tag">{branch}</span>
                        {' '.join([f'<span class="tag-label">{tag}</span>' for tag in tags_for_execution])}
                        <strong>{exec_memo}</strong>
                        <br><small>ü§ñ {model_name} | {accuracy_icon} {token_accuracy}</small>
                    </div>
                    <span class="commit-hash">{exec_hash}</span>
                </div>
                <div style="color: #6c757d; font-size: 0.9rem;">
                    üìÖ {timestamp} | üí∞ ${execution['execution_cost']:.6f} | üî¢ {execution['execution_tokens'] + execution['evaluation_tokens']:,} tokens
                </div>
            </div>
            """, unsafe_allow_html=True)
            
            # ÂÆüË°åË©≥Á¥∞
            col1, col2 = st.columns([3, 1])
            
            with col1:
                # LLM„ÅÆÂõûÁ≠îÔºàÊúÄÂÑ™ÂÖàË°®Á§∫Ôºâ
                st.write("**ü§ñ LLM„ÅÆÂõûÁ≠î**")
                st.markdown(f"""
                <div style="background: #ffffff; color: #2c3e50; padding: 2rem; border-radius: 10px; border-left: 4px solid #667eea; margin: 1rem 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <p style="color: #2c3e50; line-height: 1.6; margin: 0;">{html.escape(execution['response']).replace(chr(10), '<br>')}</p>
                </div>
                """, unsafe_allow_html=True)
                
                # Ë©ï‰æ°ÁµêÊûú
                st.write("**‚≠ê Ë©ï‰æ°ÁµêÊûú**")
                st.markdown(f"""
                <div style="background: #ffffff; color: #2c3e50; padding: 2rem; border-radius: 10px; border-left: 4px solid #f5576c; margin: 1rem 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <p style="color: #2c3e50; line-height: 1.6; margin: 0;">{html.escape(execution['evaluation']).replace(chr(10), '<br>')}</p>
                </div>
                """, unsafe_allow_html=True)
            
            with col2:
                # „É°„Éà„É™„ÇØ„Çπ
                st.metric("ÂÆüË°å„Éà„Éº„ÇØ„É≥", f"{execution['execution_tokens']:,}")
                st.metric("Ë©ï‰æ°„Éà„Éº„ÇØ„É≥", f"{execution['evaluation_tokens']:,}")
                st.metric("ÂÆüË°å„Ç≥„Çπ„Éà", f"${execution['execution_cost']:.6f}")
                st.metric("Ë©ï‰æ°„Ç≥„Çπ„ÉàÔºàÂèÇËÄÉÔºâ", f"${execution['evaluation_cost']:.6f}")
            
            # Ë©≥Á¥∞ÊÉÖÂ†±
            st.write("**üìã Ë©≥Á¥∞ÊÉÖÂ†±**")
            
            detail_col1, detail_col2 = st.columns(2)
            
            with detail_col1:
                if execution.get('execution_mode') == "„ÉÜ„É≥„Éó„É¨„Éº„Éà + „Éá„Éº„ÇøÂÖ•Âäõ":
                    st.write("**üîß „Éó„É≠„É≥„Éó„Éà„ÉÜ„É≥„Éó„É¨„Éº„Éà**")
                    st.code(execution.get('prompt_template', ''), language=None)
                    st.write("**üìä ÂÖ•Âäõ„Éá„Éº„Çø**")
                    st.code(execution.get('user_input', ''), language=None)
                
                st.write("**üìù ÊúÄÁµÇ„Éó„É≠„É≥„Éó„Éà**")
                st.code(execution.get('final_prompt', ''), language=None)
            
            with detail_col2:
                st.write("**üìã Ë©ï‰æ°Âü∫Ê∫ñ**")
                st.code(execution['criteria'], language=None)
            
            st.markdown("---")
    
    with tab3:
        st.header("üîç ÂÆüË°åÁµêÊûúÊØîËºÉ")
        
        executions_to_show = st.session_state.branches[st.session_state.current_branch]
        
        if len(executions_to_show) < 2:
            st.info("ÊØîËºÉ„Åô„Çã„Å´„ÅØÊúÄ‰Ωé2„Å§„ÅÆÂÆüË°åË®òÈå≤„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ")
            return
        
        # ÂÆüË°åË®òÈå≤ÈÅ∏Êäû
        col1, col2 = st.columns(2)
        
        execution_options = [f"{execution['commit_hash']} - {execution.get('commit_message', '„É°„É¢„Å™„Åó')}" 
                         for execution in executions_to_show]
        
        with col1:
            st.write("**ÊØîËºÉÂÖÉÂÆüË°å**")
            exec1_idx = st.selectbox("ÊØîËºÉÂÖÉ„ÇíÈÅ∏Êäû", 
                                      range(len(execution_options)), 
                                      format_func=lambda x: execution_options[x],
                                      key="exec1")
        
        with col2:
            st.write("**ÊØîËºÉÂÖàÂÆüË°å**")
            exec2_idx = st.selectbox("ÊØîËºÉÂÖà„ÇíÈÅ∏Êäû", 
                                      range(len(execution_options)), 
                                      format_func=lambda x: execution_options[x],
                                      key="exec2")
        
        if exec1_idx != exec2_idx:
            exec1 = executions_to_show[exec1_idx]
            exec2 = executions_to_show[exec2_idx]
            
            st.markdown("---")
            
            # ÊØîËºÉÁµêÊûúË°®Á§∫
            st.subheader("üìä ÊØîËºÉÁµêÊûú")
            
            # „É°„Éà„É™„ÇØ„ÇπÊØîËºÉ
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                cost_diff = exec2['execution_cost'] - exec1['execution_cost']  # ÂÆüË°å„Ç≥„Çπ„Éà„ÅÆ„Åø
                st.metric("ÂÆüË°å„Ç≥„Çπ„Éà", f"${exec2['execution_cost']:.6f}", f"{cost_diff:+.6f}")
            
            with col2:
                token_diff = (exec2['execution_tokens'] + exec2['evaluation_tokens']) - (exec1['execution_tokens'] + exec1['evaluation_tokens'])
                st.metric("Á∑è„Éà„Éº„ÇØ„É≥", f"{exec2['execution_tokens'] + exec2['evaluation_tokens']:,}", f"{token_diff:+,}")
            
            with col3:
                exec_token_diff = exec2['execution_tokens'] - exec1['execution_tokens']
                st.metric("ÂÆüË°å„Éà„Éº„ÇØ„É≥", f"{exec2['execution_tokens']:,}", f"{exec_token_diff:+,}")
            
            with col4:
                eval_token_diff = exec2['evaluation_tokens'] - exec1['evaluation_tokens']
                st.metric("Ë©ï‰æ°„Éà„Éº„ÇØ„É≥", f"{exec2['evaluation_tokens']:,}", f"{eval_token_diff:+,}")
            
            # „Éó„É≠„É≥„Éó„ÉàÂ∑ÆÂàÜ
            st.subheader("üìù „Éó„É≠„É≥„Éó„ÉàÂ∑ÆÂàÜ")
            diff_html = get_diff_html(exec1.get('final_prompt', ''), exec2.get('final_prompt', ''))
            st.markdown(diff_html, unsafe_allow_html=True)
            
            # ÂõûÁ≠îÊØîËºÉ
            st.subheader("ü§ñ LLM„ÅÆÂõûÁ≠îÊØîËºÉ")
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.write(f"**ÊØîËºÉÂÖÉ ({exec1['commit_hash']})**")
                st.markdown(f"""
                <div style="background: #ffffff; color: #2c3e50; padding: 2rem; border-radius: 10px; border-left: 4px solid #667eea; margin: 1rem 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <p style="color: #2c3e50; line-height: 1.6; margin: 0;">{html.escape(exec1['response']).replace(chr(10), '<br>')}</p>
                </div>
                """, unsafe_allow_html=True)
            
            with col2:
                st.write(f"**ÊØîËºÉÂÖà ({exec2['commit_hash']})**")
                st.markdown(f"""
                <div style="background: #ffffff; color: #2c3e50; padding: 2rem; border-radius: 10px; border-left: 4px solid #f5576c; margin: 1rem 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <p style="color: #2c3e50; line-height: 1.6; margin: 0;">{html.escape(exec2['response']).replace(chr(10), '<br>')}</p>
                </div>
                """, unsafe_allow_html=True)
            
            # Ë©ï‰æ°ÁµêÊûúÊØîËºÉ
            st.subheader("‚≠ê Ë©ï‰æ°ÁµêÊûúÊØîËºÉ")
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.write(f"**ÊØîËºÉÂÖÉ ({exec1['commit_hash']})**")
                st.markdown(f"""
                <div style="background: #ffffff; color: #2c3e50; padding: 2rem; border-radius: 10px; border-left: 4px solid #667eea; margin: 1rem 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <p style="color: #2c3e50; line-height: 1.6; margin: 0;">{html.escape(exec1['evaluation']).replace(chr(10), '<br>')}</p>
                </div>
                """, unsafe_allow_html=True)
            
            with col2:
                st.write(f"**ÊØîËºÉÂÖà ({exec2['commit_hash']})**")
                st.markdown(f"""
                <div style="background: #ffffff; color: #2c3e50; padding: 2rem; border-radius: 10px; border-left: 4px solid #f5576c; margin: 1rem 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <p style="color: #2c3e50; line-height: 1.6; margin: 0;">{html.escape(exec2['evaluation']).replace(chr(10), '<br>')}</p>
                </div>
                """, unsafe_allow_html=True)
    
    with tab4:
        st.header("üåø „Éñ„É©„É≥„ÉÅË¶ñË¶öÂåñ")
        
        if not st.session_state.evaluation_history:
            st.info("„Åæ„Å†ÂÆüË°åÂ±•Ê≠¥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ")
            return
        
        # „Éñ„É©„É≥„ÉÅÊßãÈÄ†Ë°®Á§∫
        st.subheader("üìä „Éñ„É©„É≥„ÉÅÊßãÈÄ†")
        
        for branch_name, executions in st.session_state.branches.items():
            if not executions:
                continue
                
            st.write(f"**üåø {branch_name}**")
            
            for i, execution in enumerate(executions):
                timestamp = format_timestamp(execution['timestamp'])
                timestamp_short = timestamp[5:16] if len(timestamp) >= 16 else timestamp  # MM-DD HH:MMÂΩ¢Âºè
                exec_hash = execution['commit_hash']
                exec_memo = execution.get('commit_message', '„É°„É¢„Å™„Åó')
                
                # „Çø„Ç∞„ÉÅ„Çß„ÉÉ„ÇØ
                tags_for_execution = [tag for tag, hash_val in st.session_state.tags.items() if hash_val == exec_hash]
                
                # ÂÆüË°å„É©„Ç§„É≥Ë°®Á§∫
                if i == 0:
                    st.markdown(f"```\n‚îÇ\n‚îú‚îÄ {exec_hash} {exec_memo} ({timestamp_short})")
                elif i == len(executions) - 1:
                    st.markdown(f"‚îÇ\n‚îî‚îÄ {exec_hash} {exec_memo} ({timestamp_short})")
                else:
                    st.markdown(f"‚îÇ\n‚îú‚îÄ {exec_hash} {exec_memo} ({timestamp_short})")
                
                if tags_for_execution:
                    st.markdown(f"   üè∑Ô∏è Tags: {', '.join(tags_for_execution)}")
            
            st.markdown("```")
            st.markdown("---")
        
        # Áµ±Ë®à„Çµ„Éû„É™„Éº
        st.subheader("üìà ÂÖ®‰ΩìÁµ±Ë®à")
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("Á∑è„Éñ„É©„É≥„ÉÅÊï∞", len(st.session_state.branches))
        
        with col2:
            st.metric("Á∑èÂÆüË°åÊï∞", len(st.session_state.evaluation_history))
        
        with col3:
            st.metric("Á∑è„Çø„Ç∞Êï∞", len(st.session_state.tags))
        
        with col4:
            total_cost = sum([execution['execution_cost'] for execution in st.session_state.evaluation_history])  # ÂÆüË°å„Ç≥„Çπ„Éà„ÅÆ„Åø
            st.metric("Á∑èÂÆüË°å„Ç≥„Çπ„Éà", f"${total_cost:.6f}")

if __name__ == "__main__":
    main()